From f4128bcab1730bf90d5d281360f815329f160be7 Mon Sep 17 00:00:00 2001
From: Sakar Arora <arora.sakar@gmail.com>
Date: Mon, 2 Jun 2025 15:25:35 +0530
Subject: [PATCH] wip

---
 .../__tests__/FeedbackItem.test.jsx           | 250 ++++++++++
 .../__tests__/FeedbackSummary.test.jsx        | 226 +++++++++
 .../__tests__/RecentFeedback.test.jsx         | 257 ++++++++++
 .../src/pages/__tests__/NotFound.test.jsx     | 225 +++++++++
 .../src/pages/__tests__/Settings.test.jsx     | 453 ++++++++++++++++++
 5 files changed, 1411 insertions(+)
 create mode 100644 frontend/src/components/__tests__/FeedbackItem.test.jsx
 create mode 100644 frontend/src/components/__tests__/FeedbackSummary.test.jsx
 create mode 100644 frontend/src/components/__tests__/RecentFeedback.test.jsx
 create mode 100644 frontend/src/pages/__tests__/NotFound.test.jsx
 create mode 100644 frontend/src/pages/__tests__/Settings.test.jsx

diff --git a/frontend/src/components/__tests__/FeedbackItem.test.jsx b/frontend/src/components/__tests__/FeedbackItem.test.jsx
new file mode 100644
index 0000000..7fa4ef7
--- /dev/null
+++ b/frontend/src/components/__tests__/FeedbackItem.test.jsx
@@ -0,0 +1,250 @@
+import { render, screen, fireEvent } from '@testing-library/react'
+import { describe, it, expect, vi } from 'vitest'
+import FeedbackItem from '../feedback/FeedbackItem'
+
+describe('FeedbackItem Component', () => {
+  const mockFeedbackItem = {
+    id: 1,
+    feedback_text: 'This is a great product with excellent quality and fast shipping!',
+    sentiment: 'positive',
+    source: 'Google My Business',
+    topics: ['product quality', 'shipping speed'],
+    created_at: '2024-01-15T10:30:00Z',
+    rating: 5,
+    reviewer_name: 'John Doe'
+  }
+
+  const mockFeedbackItemMinimal = {
+    id: 2,
+    feedback_text: 'Basic feedback text',
+    sentiment: 'neutral',
+    source: 'Email',
+    created_at: '2024-01-10T14:20:00Z'
+    // No topics, rating, or reviewer_name
+  }
+
+  it('renders feedback item correctly', () => {
+    render(<FeedbackItem item={mockFeedbackItem} />)
+    
+    expect(screen.getByText('This is a great product with excellent quality and fast shipping!')).toBeInTheDocument()
+    expect(screen.getByText('Positive')).toBeInTheDocument()
+    expect(screen.getByText('Google My Business')).toBeInTheDocument()
+    expect(screen.getByText('product quality')).toBeInTheDocument()
+    expect(screen.getByText('shipping speed')).toBeInTheDocument()
+    expect(screen.getByText('5')).toBeInTheDocument()
+    expect(screen.getByText('★')).toBeInTheDocument()
+  })
+
+  it('renders minimal feedback item without optional fields', () => {
+    render(<FeedbackItem item={mockFeedbackItemMinimal} />)
+    
+    expect(screen.getByText('Basic feedback text')).toBeInTheDocument()
+    expect(screen.getByText('Neutral')).toBeInTheDocument()
+    expect(screen.getByText('Email')).toBeInTheDocument()
+    
+    // Should not render rating or topics
+    expect(screen.queryByText('★')).not.toBeInTheDocument()
+    expect(screen.queryByText('product quality')).not.toBeInTheDocument()
+  })
+
+  it('formats date correctly', () => {
+    render(<FeedbackItem item={mockFeedbackItem} />)
+    
+    // Check that date is formatted (exact format may vary by locale)
+    expect(screen.getByText(/Jan.*15.*2024|15.*Jan.*2024/)).toBeInTheDocument()
+  })
+
+  it('renders different sentiment badges correctly', () => {
+    // Test positive sentiment
+    const positiveItem = { ...mockFeedbackItem, sentiment: 'positive' }
+    const { rerender } = render(<FeedbackItem item={positiveItem} />)
+    
+    let sentimentBadge = screen.getByText('Positive')
+    expect(sentimentBadge).toHaveClass('bg-green-100', 'text-green-800')
+    
+    // Test negative sentiment
+    const negativeItem = { ...mockFeedbackItem, sentiment: 'negative' }
+    rerender(<FeedbackItem item={negativeItem} />)
+    
+    sentimentBadge = screen.getByText('Negative')
+    expect(sentimentBadge).toHaveClass('bg-red-100', 'text-red-800')
+    
+    // Test neutral sentiment
+    const neutralItem = { ...mockFeedbackItem, sentiment: 'neutral' }
+    rerender(<FeedbackItem item={neutralItem} />)
+    
+    sentimentBadge = screen.getByText('Neutral')
+    expect(sentimentBadge).toHaveClass('bg-yellow-100', 'text-yellow-800')
+  })
+
+  it('handles missing sentiment gracefully', () => {
+    const itemWithoutSentiment = { ...mockFeedbackItem, sentiment: null }
+    render(<FeedbackItem item={itemWithoutSentiment} />)
+    
+    // Should not render any sentiment badge
+    expect(screen.queryByText('Positive')).not.toBeInTheDocument()
+    expect(screen.queryByText('Negative')).not.toBeInTheDocument()
+    expect(screen.queryByText('Neutral')).not.toBeInTheDocument()
+  })
+
+  it('toggles expanded state when clicked', () => {
+    render(<FeedbackItem item={mockFeedbackItem} />)
+    
+    const feedbackItem = screen.getByRole('listitem')
+    const feedbackText = screen.getByText('This is a great product with excellent quality and fast shipping!')
+    
+    // Initially should have line-clamp-2 class (collapsed)
+    expect(feedbackText).toHaveClass('line-clamp-2')
+    
+    // Click to expand
+    fireEvent.click(feedbackItem)
+    
+    // Should no longer have line-clamp-2 class (expanded)
+    expect(feedbackText).not.toHaveClass('line-clamp-2')
+    
+    // Click again to collapse
+    fireEvent.click(feedbackItem)
+    
+    // Should have line-clamp-2 class again (collapsed)
+    expect(feedbackText).toHaveClass('line-clamp-2')
+  })
+
+  it('renders multiple topics correctly', () => {
+    const itemWithManyTopics = {
+      ...mockFeedbackItem,
+      topics: ['quality', 'shipping', 'customer service', 'pricing', 'usability']
+    }
+    
+    render(<FeedbackItem item={itemWithManyTopics} />)
+    
+    expect(screen.getByText('quality')).toBeInTheDocument()
+    expect(screen.getByText('shipping')).toBeInTheDocument()
+    expect(screen.getByText('customer service')).toBeInTheDocument()
+    expect(screen.getByText('pricing')).toBeInTheDocument()
+    expect(screen.getByText('usability')).toBeInTheDocument()
+  })
+
+  it('handles empty topics array', () => {
+    const itemWithEmptyTopics = { ...mockFeedbackItem, topics: [] }
+    render(<FeedbackItem item={itemWithEmptyTopics} />)
+    
+    // Should not render any topic elements
+    expect(screen.queryByText('product quality')).not.toBeInTheDocument()
+    expect(screen.queryByText('shipping speed')).not.toBeInTheDocument()
+  })
+
+  it('handles null topics', () => {
+    const itemWithNullTopics = { ...mockFeedbackItem, topics: null }
+    render(<FeedbackItem item={itemWithNullTopics} />)
+    
+    // Should not render any topic elements
+    expect(screen.queryByText('product quality')).not.toBeInTheDocument()
+    expect(screen.queryByText('shipping speed')).not.toBeInTheDocument()
+  })
+
+  it('displays rating when present', () => {
+    render(<FeedbackItem item={mockFeedbackItem} />)
+    
+    expect(screen.getByText('★')).toBeInTheDocument()
+    expect(screen.getByText('5')).toBeInTheDocument()
+  })
+
+  it('hides rating when not present', () => {
+    const itemWithoutRating = { ...mockFeedbackItem, rating: null }
+    render(<FeedbackItem item={itemWithoutRating} />)
+    
+    expect(screen.queryByText('★')).not.toBeInTheDocument()
+  })
+
+  it('handles different rating values', () => {
+    const itemWithLowRating = { ...mockFeedbackItem, rating: 2 }
+    render(<FeedbackItem item={itemWithLowRating} />)
+    
+    expect(screen.getByText('★')).toBeInTheDocument()
+    expect(screen.getByText('2')).toBeInTheDocument()
+  })
+
+  it('displays source correctly', () => {
+    // Test different sources
+    const sources = ['Email', 'Survey', 'Web Widget', 'Google My Business']
+    
+    sources.forEach(source => {
+      const itemWithSource = { ...mockFeedbackItem, source }
+      const { rerender } = render(<FeedbackItem item={itemWithSource} />)
+      
+      expect(screen.getByText(source)).toBeInTheDocument()
+      
+      if (source !== sources[sources.length - 1]) {
+        rerender(<div />) // Clear between renders
+      }
+    })
+  })
+
+  it('has proper accessibility attributes', () => {
+    render(<FeedbackItem item={mockFeedbackItem} />)
+    
+    const listItem = screen.getByRole('listitem')
+    expect(listItem).toBeInTheDocument()
+    expect(listItem).toHaveClass('cursor-pointer')
+  })
+
+  it('handles very long feedback text', () => {
+    const longText = 'This is a very long feedback text that should be truncated when not expanded. '.repeat(10)
+    const itemWithLongText = { ...mockFeedbackItem, feedback_text: longText }
+    
+    render(<FeedbackItem item={itemWithLongText} />)
+    
+    // Find the feedback text element using a partial match
+    const feedbackText = screen.getByText(/This is a very long feedback text/)
+    expect(feedbackText).toHaveClass('line-clamp-2')
+    
+    // Click to expand
+    fireEvent.click(screen.getByRole('listitem'))
+    
+    // Should no longer be truncated
+    expect(feedbackText).not.toHaveClass('line-clamp-2')
+  })
+
+  it('handles edge case with invalid date', () => {
+    const itemWithInvalidDate = { ...mockFeedbackItem, created_at: 'invalid-date' }
+    render(<FeedbackItem item={itemWithInvalidDate} />)
+    
+    // Should not crash, but might show "Invalid Date" - this is acceptable
+    expect(screen.getByRole('listitem')).toBeInTheDocument()
+  })
+
+  it('capitalizes sentiment correctly', () => {
+    const sentiments = ['positive', 'negative', 'neutral']
+    
+    sentiments.forEach(sentiment => {
+      const itemWithSentiment = { ...mockFeedbackItem, sentiment }
+      const { rerender } = render(<FeedbackItem item={itemWithSentiment} />)
+      
+      const expectedText = sentiment.charAt(0).toUpperCase() + sentiment.slice(1)
+      expect(screen.getByText(expectedText)).toBeInTheDocument()
+      
+      if (sentiment !== sentiments[sentiments.length - 1]) {
+        rerender(<div />) // Clear between renders
+      }
+    })
+  })
+
+  it('renders topic chips with correct styling', () => {
+    render(<FeedbackItem item={mockFeedbackItem} />)
+    
+    const topicChip = screen.getByText('product quality')
+    expect(topicChip).toHaveClass('bg-gray-100', 'text-gray-800', 'text-xs')
+  })
+
+  it('displays feedback metadata correctly', () => {
+    render(<FeedbackItem item={mockFeedbackItem} />)
+    
+    // Check for date, source, and rating in metadata section
+    expect(screen.getByText(/Jan.*15.*2024|15.*Jan.*2024/)).toBeInTheDocument()
+    expect(screen.getByText('Google My Business')).toBeInTheDocument()
+    expect(screen.getByText('5')).toBeInTheDocument()
+    
+    // Check for separator
+    expect(screen.getByText('·')).toBeInTheDocument()
+  })
+})
diff --git a/frontend/src/components/__tests__/FeedbackSummary.test.jsx b/frontend/src/components/__tests__/FeedbackSummary.test.jsx
new file mode 100644
index 0000000..b70c01b
--- /dev/null
+++ b/frontend/src/components/__tests__/FeedbackSummary.test.jsx
@@ -0,0 +1,226 @@
+import { render, screen } from '@testing-library/react'
+import { describe, it, expect } from 'vitest'
+import FeedbackSummary from '../dashboard/FeedbackSummary'
+
+describe('FeedbackSummary Component', () => {
+  const mockData = {
+    positive: 15,
+    negative: 5,
+    neutral: 8,
+    total: 28
+  }
+
+  const mockEmptyData = {
+    positive: 0,
+    negative: 0,
+    neutral: 0,
+    total: 0
+  }
+
+  const mockSingleItemData = {
+    positive: 1,
+    negative: 0,
+    neutral: 0,
+    total: 1
+  }
+
+  it('renders feedback summary correctly with data', () => {
+    render(<FeedbackSummary data={mockData} />)
+    
+    // Check total feedback display
+    expect(screen.getByText('Total Feedback')).toBeInTheDocument()
+    expect(screen.getByText('28')).toBeInTheDocument()
+    
+    // Check sentiment labels
+    expect(screen.getByText('Positive')).toBeInTheDocument()
+    expect(screen.getByText('Neutral')).toBeInTheDocument()
+    expect(screen.getByText('Negative')).toBeInTheDocument()
+  })
+
+  it('calculates and displays percentages correctly', () => {
+    render(<FeedbackSummary data={mockData} />)
+    
+    // Positive: 15/28 = 53.57% → rounds to 54%
+    expect(screen.getByText('15 (54%)')).toBeInTheDocument()
+    
+    // Neutral: 8/28 = 28.57% → rounds to 29%
+    expect(screen.getByText('8 (29%)')).toBeInTheDocument()
+    
+    // Negative: 5/28 = 17.86% → rounds to 18%
+    expect(screen.getByText('5 (18%)')).toBeInTheDocument()
+  })
+
+  it('handles zero data correctly', () => {
+    render(<FeedbackSummary data={mockEmptyData} />)
+    
+    // Should show 0 for total
+    expect(screen.getByText('0')).toBeInTheDocument() // Total
+    
+    // Check that all sentiment categories show 0 (0%)
+    const zeroPercentages = screen.getAllByText('0 (0%)')
+    expect(zeroPercentages).toHaveLength(3) // positive, neutral, negative
+  })
+
+  it('handles single item data correctly', () => {
+    render(<FeedbackSummary data={mockSingleItemData} />)
+    
+    expect(screen.getByText('1')).toBeInTheDocument() // Total
+    expect(screen.getByText('1 (100%)')).toBeInTheDocument() // Positive
+    
+    // Should have two entries with 0 (0%) for neutral and negative
+    const zeroPercentages = screen.getAllByText('0 (0%)')
+    expect(zeroPercentages).toHaveLength(2) // neutral and negative
+  })
+
+  it('renders progress bars with correct widths', () => {
+    render(<FeedbackSummary data={mockData} />)
+    
+    // Get progress bars by their CSS classes
+    const positiveBar = document.querySelector('.bg-green-600')
+    const neutralBar = document.querySelector('.bg-yellow-500')
+    const negativeBar = document.querySelector('.bg-red-600')
+    
+    // Check positive progress bar (54%)
+    expect(positiveBar).toHaveStyle({ width: '54%' })
+    expect(positiveBar).toHaveClass('bg-green-600')
+    
+    // Check neutral progress bar (29%)
+    expect(neutralBar).toHaveStyle({ width: '29%' })
+    expect(neutralBar).toHaveClass('bg-yellow-500')
+    
+    // Check negative progress bar (18%)
+    expect(negativeBar).toHaveStyle({ width: '18%' })
+    expect(negativeBar).toHaveClass('bg-red-600')
+  })
+
+  it('applies correct CSS classes for sentiment colors', () => {
+    render(<FeedbackSummary data={mockData} />)
+    
+    // Check positive sentiment styling
+    const positiveLabel = screen.getByText('Positive')
+    expect(positiveLabel).toHaveClass('text-green-600')
+    
+    // Check neutral sentiment styling
+    const neutralLabel = screen.getByText('Neutral')
+    expect(neutralLabel).toHaveClass('text-yellow-500')
+    
+    // Check negative sentiment styling
+    const negativeLabel = screen.getByText('Negative')
+    expect(negativeLabel).toHaveClass('text-red-600')
+  })
+
+  it('renders divider line', () => {
+    const { container } = render(<FeedbackSummary data={mockData} />)
+    
+    // Check for divider element
+    const divider = container.querySelector('.h-px.bg-gray-200')
+    expect(divider).toBeInTheDocument()
+  })
+
+  it('handles edge case with high numbers', () => {
+    const largeData = {
+      positive: 9500,
+      negative: 300,
+      neutral: 200,
+      total: 10000
+    }
+    
+    render(<FeedbackSummary data={largeData} />)
+    
+    expect(screen.getByText('10000')).toBeInTheDocument()
+    expect(screen.getByText('9500 (95%)')).toBeInTheDocument()
+    expect(screen.getByText('200 (2%)')).toBeInTheDocument()
+    expect(screen.getByText('300 (3%)')).toBeInTheDocument()
+  })
+
+  it('handles fractional percentages correctly', () => {
+    const fractionalData = {
+      positive: 1,
+      negative: 1,
+      neutral: 1,
+      total: 3
+    }
+    
+    render(<FeedbackSummary data={fractionalData} />)
+    
+    // 1/3 = 33.33% should round to 33%
+    // All three sentiments should show 1 (33%)
+    const percentages = screen.getAllByText('1 (33%)')
+    expect(percentages).toHaveLength(3)
+  })
+
+  it('maintains semantic structure', () => {
+    render(<FeedbackSummary data={mockData} />)
+    
+    // Check that the component has proper semantic structure
+    expect(screen.getByText('Total Feedback')).toBeInTheDocument()
+    
+    // All sentiment categories should be present
+    expect(screen.getByText('Positive')).toBeInTheDocument()
+    expect(screen.getByText('Neutral')).toBeInTheDocument()
+    expect(screen.getByText('Negative')).toBeInTheDocument()
+  })
+
+  it('handles missing data properties gracefully', () => {
+    const incompleteData = {
+      positive: 5,
+      total: 10
+      // missing negative and neutral
+    }
+    
+    render(<FeedbackSummary data={incompleteData} />)
+    
+    // Should still render without crashing
+    expect(screen.getByText('Total Feedback')).toBeInTheDocument()
+    expect(screen.getByText('10')).toBeInTheDocument()
+  })
+
+  it('handles undefined data object', () => {
+    // This tests the component's resilience to missing props
+    const { container } = render(<FeedbackSummary data={{}} />)
+    
+    // Should render basic structure without crashing
+    expect(container).toBeInTheDocument()
+  })
+
+  it('displays progress bars with correct accessibility attributes', () => {
+    render(<FeedbackSummary data={mockData} />)
+    
+    // Check that progress bars have proper styling by finding them by CSS class
+    const progressBars = document.querySelectorAll('.bg-green-600, .bg-yellow-500, .bg-red-600')
+    expect(progressBars).toHaveLength(3)
+    
+    // Each progress bar should have proper styling
+    progressBars.forEach(bar => {
+      expect(bar).toHaveClass('h-2.5', 'rounded-full')
+    })
+  })
+
+  it('maintains consistent spacing and layout', () => {
+    const { container } = render(<FeedbackSummary data={mockData} />)
+    
+    // Check main container has proper spacing
+    const mainContainer = container.firstChild
+    expect(mainContainer).toHaveClass('space-y-4')
+    
+    // Check individual sections have proper spacing
+    const sections = container.querySelectorAll('.space-y-2')
+    expect(sections).toHaveLength(3) // One for each sentiment
+  })
+
+  it('rounds percentages to whole numbers', () => {
+    const preciseData = {
+      positive: 7,
+      negative: 3,
+      neutral: 4,
+      total: 14
+    }
+    
+    render(<FeedbackSummary data={preciseData} />)
+    
+    // 7/14 = 50%, 3/14 ≈ 21.43% → 21%, 4/14 ≈ 28.57% → 29%
+    expect(screen.getByText('7 (50%)')).toBeInTheDocument()
+    expect(screen.getByText('3 (21%)')).toBeInTheDocument()
+    expect(screen.getByText('4 (29%)')).toBeInTheDocument()
+  })
+})
diff --git a/frontend/src/components/__tests__/RecentFeedback.test.jsx b/frontend/src/components/__tests__/RecentFeedback.test.jsx
new file mode 100644
index 0000000..04b4392
--- /dev/null
+++ b/frontend/src/components/__tests__/RecentFeedback.test.jsx
@@ -0,0 +1,257 @@
+import { render, screen } from '@testing-library/react'
+import { BrowserRouter } from 'react-router-dom'
+import { describe, it, expect, vi } from 'vitest'
+import RecentFeedback from '../dashboard/RecentFeedback'
+
+// Mock react-router-dom
+vi.mock('react-router-dom', async () => {
+  const actual = await vi.importActual('react-router-dom')
+  return {
+    ...actual,
+    Link: ({ children, to, ...props }) => <a href={to} {...props}>{children}</a>
+  }
+})
+
+// Wrapper component for router context
+const renderWithRouter = (component) => {
+  return render(
+    <BrowserRouter>
+      {component}
+    </BrowserRouter>
+  )
+}
+
+describe('RecentFeedback Component', () => {
+  const mockRecentItems = [
+    {
+      id: 1,
+      feedback_text: 'Great product with excellent quality!',
+      sentiment: 'positive',
+      source: 'Google My Business',
+      created_at: '2024-01-15T10:30:00Z'
+    },
+    {
+      id: 2,
+      feedback_text: 'Could be better in terms of delivery speed',
+      sentiment: 'neutral',
+      source: 'Email',
+      created_at: '2024-01-14T09:20:00Z'
+    },
+    {
+      id: 3,
+      feedback_text: 'Very disappointed with the service quality and customer support response time',
+      sentiment: 'negative',
+      source: 'Survey',
+      created_at: '2024-01-13T14:15:00Z'
+    }
+  ]
+
+  const mockLongTextItem = {
+    id: 4,
+    feedback_text: 'This is an extremely long feedback text that should be truncated because it exceeds the 100 character limit set by the component for display purposes in the recent feedback section',
+    sentiment: 'positive',
+    source: 'Web Widget',
+    created_at: '2024-01-12T11:45:00Z'
+  }
+
+  it('renders recent feedback items correctly', () => {
+    renderWithRouter(<RecentFeedback items={mockRecentItems} />)
+    
+    expect(screen.getByText('Great product with excellent quality!')).toBeInTheDocument()
+    expect(screen.getByText('Could be better in terms of delivery speed')).toBeInTheDocument()
+    expect(screen.getByText(/Very disappointed with the service quality/)).toBeInTheDocument()
+  })
+
+  it('displays sentiment badges correctly', () => {
+    renderWithRouter(<RecentFeedback items={mockRecentItems} />)
+    
+    // Check for sentiment badges
+    expect(screen.getByText('Positive')).toBeInTheDocument()
+    expect(screen.getByText('Neutral')).toBeInTheDocument()
+    expect(screen.getByText('Negative')).toBeInTheDocument()
+    
+    // Check badge styling
+    const positiveBadge = screen.getByText('Positive')
+    expect(positiveBadge).toHaveClass('bg-green-100', 'text-green-800')
+    
+    const neutralBadge = screen.getByText('Neutral')
+    expect(neutralBadge).toHaveClass('bg-yellow-100', 'text-yellow-800')
+    
+    const negativeBadge = screen.getByText('Negative')
+    expect(negativeBadge).toHaveClass('bg-red-100', 'text-red-800')
+  })
+
+  it('displays feedback sources and dates', () => {
+    renderWithRouter(<RecentFeedback items={mockRecentItems} />)
+    
+    expect(screen.getByText('Google My Business')).toBeInTheDocument()
+    expect(screen.getByText('Email')).toBeInTheDocument()
+    expect(screen.getByText('Survey')).toBeInTheDocument()
+    
+    // Check date formatting (dates should be formatted as locale strings)
+    expect(screen.getByText(/1\/15\/2024|15\/1\/2024|Jan.*15.*2024/)).toBeInTheDocument()
+  })
+
+  it('truncates long feedback text', () => {
+    renderWithRouter(<RecentFeedback items={[mockLongTextItem]} />)
+    
+    // Should show truncated text with ellipsis
+    expect(screen.getByText(/This is an extremely long feedback text.*\.\.\./)).toBeInTheDocument()
+    
+    // Should not show the full text
+    expect(screen.queryByText(/display purposes in the recent feedback section/)).not.toBeInTheDocument()
+  })
+
+  it('renders "View all feedback" link', () => {
+    renderWithRouter(<RecentFeedback items={mockRecentItems} />)
+    
+    const viewAllLink = screen.getByText('View all feedback')
+    expect(viewAllLink).toBeInTheDocument()
+    expect(viewAllLink.closest('a')).toHaveAttribute('href', '/feedback')
+  })
+
+  it('shows empty state when no items provided', () => {
+    renderWithRouter(<RecentFeedback items={[]} />)
+    
+    expect(screen.getByText('No feedback available yet')).toBeInTheDocument()
+    expect(screen.queryByText('View all feedback')).not.toBeInTheDocument()
+  })
+
+  it('handles null items gracefully', () => {
+    renderWithRouter(<RecentFeedback items={null} />)
+    
+    expect(screen.getByText('No feedback available yet')).toBeInTheDocument()
+  })
+
+  it('handles undefined items gracefully', () => {
+    renderWithRouter(<RecentFeedback />)
+    
+    expect(screen.getByText('No feedback available yet')).toBeInTheDocument()
+  })
+
+  it('handles items with missing sentiment', () => {
+    const itemWithoutSentiment = {
+      id: 5,
+      feedback_text: 'Feedback without sentiment',
+      source: 'Email',
+      created_at: '2024-01-10T12:00:00Z'
+    }
+    
+    renderWithRouter(<RecentFeedback items={[itemWithoutSentiment]} />)
+    
+    expect(screen.getByText('Feedback without sentiment')).toBeInTheDocument()
+    // Should not render any sentiment badge
+    expect(screen.queryByText('Positive')).not.toBeInTheDocument()
+    expect(screen.queryByText('Negative')).not.toBeInTheDocument()
+    expect(screen.queryByText('Neutral')).not.toBeInTheDocument()
+  })
+
+  it('handles items with missing feedback text', () => {
+    const itemWithoutText = {
+      id: 6,
+      sentiment: 'positive',
+      source: 'Email',
+      created_at: '2024-01-10T12:00:00Z'
+    }
+    
+    renderWithRouter(<RecentFeedback items={[itemWithoutText]} />)
+    
+    expect(screen.getByText('No feedback text available')).toBeInTheDocument()
+  })
+
+  it('handles items with missing date', () => {
+    const itemWithoutDate = {
+      id: 7,
+      feedback_text: 'Feedback without date',
+      sentiment: 'positive',
+      source: 'Email'
+    }
+    
+    renderWithRouter(<RecentFeedback items={[itemWithoutDate]} />)
+    
+    expect(screen.getByText('No date')).toBeInTheDocument()
+  })
+
+  it('handles items with missing source', () => {
+    const itemWithoutSource = {
+      id: 8,
+      feedback_text: 'Feedback without source',
+      sentiment: 'positive',
+      created_at: '2024-01-10T12:00:00Z'
+    }
+    
+    renderWithRouter(<RecentFeedback items={[itemWithoutSource]} />)
+    
+    expect(screen.getByText('Unknown source')).toBeInTheDocument()
+  })
+
+  it('handles invalid date gracefully', () => {
+    const itemWithInvalidDate = {
+      id: 9,
+      feedback_text: 'Feedback with invalid date',
+      sentiment: 'positive',
+      source: 'Email',
+      created_at: 'invalid-date'
+    }
+    
+    renderWithRouter(<RecentFeedback items={[itemWithInvalidDate]} />)
+    
+    // Should render without crashing
+    expect(screen.getByText('Feedback with invalid date')).toBeInTheDocument()
+  })
+
+  it('capitalizes sentiment text correctly', () => {
+    const itemsWithLowercaseSentiment = [
+      { ...mockRecentItems[0], sentiment: 'positive' },
+      { ...mockRecentItems[1], sentiment: 'neutral' },
+      { ...mockRecentItems[2], sentiment: 'negative' }
+    ]
+    
+    renderWithRouter(<RecentFeedback items={itemsWithLowercaseSentiment} />)
+    
+    expect(screen.getByText('Positive')).toBeInTheDocument()
+    expect(screen.getByText('Neutral')).toBeInTheDocument()
+    expect(screen.getByText('Negative')).toBeInTheDocument()
+  })
+
+  it('renders correct number of items', () => {
+    renderWithRouter(<RecentFeedback items={mockRecentItems} />)
+    
+    // Should render all 3 items
+    const listItems = screen.getAllByRole('listitem')
+    expect(listItems).toHaveLength(3)
+  })
+
+  it('handles empty string feedback text', () => {
+    const itemWithEmptyText = {
+      id: 10,
+      feedback_text: '',
+      sentiment: 'positive',
+      source: 'Email',
+      created_at: '2024-01-10T12:00:00Z'
+    }
+    
+    renderWithRouter(<RecentFeedback items={[itemWithEmptyText]} />)
+    
+    expect(screen.getByText('No feedback text available')).toBeInTheDocument()
+  })
+
+  it('displays separator between date and source', () => {
+    renderWithRouter(<RecentFeedback items={mockRecentItems} />)
+    
+    // Check for middot separator
+    expect(screen.getAllByText('·')).toHaveLength(mockRecentItems.length)
+  })
+
+  it('applies correct CSS classes for styling', () => {
+    renderWithRouter(<RecentFeedback items={mockRecentItems} />)
+    
+    // Check for main container classes
+    const container = screen.getByRole('list')
+    expect(container).toHaveClass('divide-y', 'divide-gray-200')
+    
+    // Check link styling
+    const viewAllLink = screen.getByText('View all feedback')
+    expect(viewAllLink).toHaveClass('text-primary-600', 'hover:text-primary-500')
+  })
+})
diff --git a/frontend/src/pages/__tests__/NotFound.test.jsx b/frontend/src/pages/__tests__/NotFound.test.jsx
new file mode 100644
index 0000000..38507c9
--- /dev/null
+++ b/frontend/src/pages/__tests__/NotFound.test.jsx
@@ -0,0 +1,225 @@
+import { render, screen } from '@testing-library/react'
+import { BrowserRouter } from 'react-router-dom'
+import { describe, it, expect, vi } from 'vitest'
+import NotFound from '../NotFound'
+
+// Mock react-router-dom Link component
+vi.mock('react-router-dom', async () => {
+  const actual = await vi.importActual('react-router-dom')
+  return {
+    ...actual,
+    Link: ({ children, to, ...props }) => <a href={to} {...props}>{children}</a>
+  }
+})
+
+// Wrapper component for router context
+const renderWithRouter = (component) => {
+  return render(
+    <BrowserRouter>
+      {component}
+    </BrowserRouter>
+  )
+}
+
+describe('NotFound Component', () => {
+  it('renders 404 page correctly', () => {
+    renderWithRouter(<NotFound />)
+    
+    // Check main elements
+    expect(screen.getByText('404')).toBeInTheDocument()
+    expect(screen.getByText('Page not found')).toBeInTheDocument()
+    expect(screen.getByText("Sorry, we couldn't find the page you're looking for.")).toBeInTheDocument()
+    expect(screen.getByText('Go back home')).toBeInTheDocument()
+  })
+
+  it('displays large 404 heading', () => {
+    renderWithRouter(<NotFound />)
+    
+    const heading404 = screen.getByText('404')
+    expect(heading404).toBeInTheDocument()
+    expect(heading404).toHaveClass('text-9xl', 'font-bold', 'text-primary-600')
+  })
+
+  it('displays proper heading hierarchy', () => {
+    renderWithRouter(<NotFound />)
+    
+    // Check heading levels
+    const mainHeading = screen.getByRole('heading', { level: 1 })
+    expect(mainHeading).toHaveTextContent('404')
+    
+    const subHeading = screen.getByRole('heading', { level: 2 })
+    expect(subHeading).toHaveTextContent('Page not found')
+  })
+
+  it('displays descriptive error message', () => {
+    renderWithRouter(<NotFound />)
+    
+    const errorMessage = screen.getByText("Sorry, we couldn't find the page you're looking for.")
+    expect(errorMessage).toBeInTheDocument()
+    expect(errorMessage).toHaveClass('text-base', 'text-gray-500')
+  })
+
+  it('renders home link with correct attributes', () => {
+    renderWithRouter(<NotFound />)
+    
+    const homeLink = screen.getByText('Go back home')
+    expect(homeLink).toBeInTheDocument()
+    
+    // Check link attributes
+    const linkElement = homeLink.closest('a')
+    expect(linkElement).toHaveAttribute('href', '/')
+  })
+
+  it('applies correct CSS classes for styling', () => {
+    renderWithRouter(<NotFound />)
+    
+    // Check main container styling
+    const container = screen.getByText('404').closest('div')
+    expect(container.parentElement).toHaveClass('min-h-screen', 'flex', 'items-center', 'justify-center', 'bg-gray-50')
+    
+    // Check content container
+    expect(container).toHaveClass('max-w-md', 'w-full', 'text-center')
+    
+    // Check sub-heading styling
+    const subHeading = screen.getByText('Page not found')
+    expect(subHeading).toHaveClass('mt-4', 'text-3xl', 'font-extrabold', 'text-gray-900')
+    
+    // Check button styling
+    const homeLink = screen.getByText('Go back home')
+    expect(homeLink).toHaveClass(
+      'inline-flex', 'items-center', 'px-4', 'py-2', 'border', 'border-transparent',
+      'text-sm', 'font-medium', 'rounded-md', 'shadow-sm', 'text-white',
+      'bg-primary-600', 'hover:bg-primary-700'
+    )
+  })
+
+  it('has proper semantic structure', () => {
+    renderWithRouter(<NotFound />)
+    
+    // Check that there are exactly 2 headings
+    const headings = screen.getAllByRole('heading')
+    expect(headings).toHaveLength(2)
+    
+    // Check that there's a link
+    const links = screen.getAllByRole('link')
+    expect(links).toHaveLength(1)
+    expect(links[0]).toHaveTextContent('Go back home')
+  })
+
+  it('maintains responsive design classes', () => {
+    renderWithRouter(<NotFound />)
+    
+    // Check responsive padding classes
+    const mainContainer = screen.getByText('404').closest('div').parentElement
+    expect(mainContainer).toHaveClass('py-12', 'px-4', 'sm:px-6', 'lg:px-8')
+  })
+
+  it('uses consistent color scheme', () => {
+    renderWithRouter(<NotFound />)
+    
+    // Check primary color usage
+    const heading404 = screen.getByText('404')
+    expect(heading404).toHaveClass('text-primary-600')
+    
+    const homeLink = screen.getByText('Go back home')
+    expect(homeLink).toHaveClass('bg-primary-600', 'hover:bg-primary-700')
+    
+    // Check gray color usage for text
+    const errorMessage = screen.getByText("Sorry, we couldn't find the page you're looking for.")
+    expect(errorMessage).toHaveClass('text-gray-500')
+    
+    const subHeading = screen.getByText('Page not found')
+    expect(subHeading).toHaveClass('text-gray-900')
+  })
+
+  it('has proper focus management for accessibility', () => {
+    renderWithRouter(<NotFound />)
+    
+    const homeLink = screen.getByText('Go back home')
+    expect(homeLink).toHaveClass('focus:outline-none', 'focus:ring-2', 'focus:ring-offset-2', 'focus:ring-primary-500')
+  })
+
+  it('renders as a complete page layout', () => {
+    renderWithRouter(<NotFound />)
+    
+    // Should have min-height screen for full page layout
+    const pageContainer = screen.getByText('404').closest('div').parentElement
+    expect(pageContainer).toHaveClass('min-h-screen')
+    
+    // Should be centered both horizontally and vertically
+    expect(pageContainer).toHaveClass('flex', 'items-center', 'justify-center')
+  })
+
+  it('displays content in correct order', () => {
+    renderWithRouter(<NotFound />)
+    
+    const container = screen.getByText('404').closest('div')
+    const children = Array.from(container.children)
+    
+    // Check content order
+    expect(children[0]).toHaveTextContent('404')
+    expect(children[1]).toHaveTextContent('Page not found')
+    expect(children[2]).toHaveTextContent("Sorry, we couldn't find the page you're looking for.")
+    expect(children[3]).toContainElement(screen.getByText('Go back home'))
+  })
+
+  it('has appropriate spacing between elements', () => {
+    renderWithRouter(<NotFound />)
+    
+    // Check spacing classes
+    const subHeading = screen.getByText('Page not found')
+    expect(subHeading).toHaveClass('mt-4')
+    
+    const errorMessage = screen.getByText("Sorry, we couldn't find the page you're looking for.")
+    expect(errorMessage).toHaveClass('mt-2')
+    
+    const linkContainer = screen.getByText('Go back home').closest('div')
+    expect(linkContainer).toHaveClass('mt-6')
+  })
+
+  it('renders without any console errors', () => {
+    // This test ensures the component renders cleanly
+    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})
+    
+    renderWithRouter(<NotFound />)
+    
+    expect(consoleSpy).not.toHaveBeenCalled()
+    
+    consoleSpy.mockRestore()
+  })
+
+  it('handles router context properly', () => {
+    // Test that the component doesn't crash when rendered outside router context
+    // by ensuring our mock Link component works
+    renderWithRouter(<NotFound />)
+    
+    const homeLink = screen.getByText('Go back home')
+    expect(homeLink.closest('a')).toHaveAttribute('href', '/')
+  })
+
+  it('is keyboard accessible', () => {
+    renderWithRouter(<NotFound />)
+    
+    const homeLink = screen.getByText('Go back home')
+    
+    // Should be focusable
+    expect(homeLink.closest('a')).toHaveAttribute('href')
+    
+    // Should have proper focus styles
+    expect(homeLink).toHaveClass('focus:outline-none', 'focus:ring-2')
+  })
+
+  it('displays consistent typography', () => {
+    renderWithRouter(<NotFound />)
+    
+    // Check font weights and sizes
+    const heading404 = screen.getByText('404')
+    expect(heading404).toHaveClass('font-bold')
+    
+    const subHeading = screen.getByText('Page not found')
+    expect(subHeading).toHaveClass('font-extrabold')
+    
+    const homeLink = screen.getByText('Go back home')
+    expect(homeLink).toHaveClass('font-medium')
+  })
+})
diff --git a/frontend/src/pages/__tests__/Settings.test.jsx b/frontend/src/pages/__tests__/Settings.test.jsx
new file mode 100644
index 0000000..2dfd146
--- /dev/null
+++ b/frontend/src/pages/__tests__/Settings.test.jsx
@@ -0,0 +1,453 @@
+import { render, screen, fireEvent, waitFor, act } from '@testing-library/react'
+import { describe, it, expect, vi, beforeEach } from 'vitest'
+import userEvent from '@testing-library/user-event'
+import { flushSync } from 'react-dom'
+import Settings from '../Settings'
+
+// Mock the API service
+vi.mock('../../services/api', () => ({
+  default: {
+    put: vi.fn()
+  }
+}))
+
+// Import the mocked API
+import api from '../../services/api'
+const mockApiPut = vi.mocked(api.put)
+
+// Mock react-query
+let mockMutationReturn = {
+  mutate: vi.fn(),
+  isLoading: false,
+  isError: false,
+  isSuccess: false,
+  error: null
+}
+
+vi.mock('react-query', () => ({
+  useMutation: vi.fn(() => mockMutationReturn)
+}))
+
+// Import the mocked useMutation
+import { useMutation } from 'react-query'
+const mockUseMutation = vi.mocked(useMutation)
+
+// Mock the auth store
+const mockAuthStore = {
+  user: {
+    id: 1,
+    email: 'test@example.com',
+    business_name: 'Test Business'
+  },
+  logout: vi.fn()
+}
+
+vi.mock('../../store/authStore', () => ({
+  useAuthStore: () => mockAuthStore
+}))
+
+describe('Settings Component', () => {
+  beforeEach(() => {
+    vi.clearAllMocks()
+    // Reset the mock user state
+    mockAuthStore.user = {
+      id: 1,
+      email: 'test@example.com',
+      business_name: 'Test Business'
+    }
+    // Reset the mutation mock
+    mockMutationReturn = {
+      mutate: vi.fn(),
+      isLoading: false,
+      isError: false,
+      isSuccess: false,
+      error: null
+    }
+    mockUseMutation.mockReturnValue(mockMutationReturn)
+    mockApiPut.mockResolvedValue({ data: {} })
+  })
+
+  it('renders settings page correctly', () => {
+    render(<Settings />)
+    
+    expect(screen.getByText('Settings')).toBeInTheDocument()
+    expect(screen.getByText('Account Settings')).toBeInTheDocument()
+    expect(screen.getByText('Data Management')).toBeInTheDocument()
+    expect(screen.getByText('Subscription')).toBeInTheDocument()
+  })
+
+  it('displays user information correctly', () => {
+    render(<Settings />)
+    
+    // Check email field (disabled)
+    const emailInput = screen.getByDisplayValue('test@example.com')
+    expect(emailInput).toBeInTheDocument()
+    expect(emailInput).toBeDisabled()
+    expect(screen.getByText('Email address cannot be changed')).toBeInTheDocument()
+    
+    // Check business name field (editable)
+    const businessNameInput = screen.getByDisplayValue('Test Business')
+    expect(businessNameInput).toBeInTheDocument()
+    expect(businessNameInput).not.toBeDisabled()
+  })
+
+  it('allows editing business name', async () => {
+    render(<Settings />)
+    
+    const businessNameInput = screen.getByDisplayValue('Test Business')
+    
+    // Use fireEvent wrapped in act instead of userEvent
+    act(() => {
+      fireEvent.change(businessNameInput, {
+        target: { value: 'New Business Name' }
+      })
+    })
+    
+    // Verify the final state
+    expect(businessNameInput).toHaveValue('New Business Name')
+  })
+
+  it('submits business name update on form submission', async () => {
+    render(<Settings />)
+    
+    const businessNameInput = screen.getByDisplayValue('Test Business')
+    const submitButton = screen.getByText('Save Changes')
+    
+    // Change business name using fireEvent wrapped in act
+    act(() => {
+      fireEvent.change(businessNameInput, {
+        target: { value: 'Updated Business' }
+      })
+    })
+    
+    // Submit form using fireEvent wrapped in act
+    act(() => {
+      fireEvent.click(submitButton)
+    })
+    
+    // Wait for the mutation to be called
+    await waitFor(() => {
+      expect(mockMutationReturn.mutate).toHaveBeenCalledWith('Updated Business')
+    })
+  })
+
+  it('prevents submission with empty business name', async () => {
+    render(<Settings />)
+    
+    const businessNameInput = screen.getByDisplayValue('Test Business')
+    const submitButton = screen.getByText('Save Changes')
+    
+    // Clear business name using fireEvent wrapped in act
+    act(() => {
+      fireEvent.change(businessNameInput, {
+        target: { value: '' }
+      })
+    })
+    
+    // Submit form using fireEvent wrapped in act
+    act(() => {
+      fireEvent.click(submitButton)
+    })
+    
+    // Wait for the validation message to appear
+    await waitFor(() => {
+      expect(screen.getByText('Business name cannot be empty')).toBeInTheDocument()
+    })
+    expect(mockMutationReturn.mutate).not.toHaveBeenCalled()
+  })
+
+  it('prevents submission with whitespace-only business name', async () => {
+    render(<Settings />)
+    
+    const businessNameInput = screen.getByDisplayValue('Test Business')
+    const submitButton = screen.getByText('Save Changes')
+    
+    // Enter only whitespace using fireEvent wrapped in act
+    act(() => {
+      fireEvent.change(businessNameInput, {
+        target: { value: '   ' }
+      })
+    })
+    
+    // Submit form using fireEvent wrapped in act
+    act(() => {
+      fireEvent.click(submitButton)
+    })
+    
+    // Wait for the validation message to appear
+    await waitFor(() => {
+      expect(screen.getByText('Business name cannot be empty')).toBeInTheDocument()
+    })
+    expect(mockMutationReturn.mutate).not.toHaveBeenCalled()
+  })
+
+  it('shows loading state during submission', () => {
+    // Set up the mock to return loading state
+    mockMutationReturn.isLoading = true
+    mockUseMutation.mockReturnValue(mockMutationReturn)
+    
+    render(<Settings />)
+    
+    const submitButton = screen.getByText('Saving...')
+    expect(submitButton).toBeInTheDocument()
+    expect(submitButton).toBeDisabled()
+  })
+
+  it('displays subscription information', () => {
+    render(<Settings />)
+    
+    expect(screen.getByText('Free Tier')).toBeInTheDocument()
+    expect(screen.getByText('You are currently on the Free Tier, which includes:')).toBeInTheDocument()
+    expect(screen.getByText('Up to 100 feedback items per month')).toBeInTheDocument()
+    expect(screen.getByText('Basic sentiment analysis')).toBeInTheDocument()
+    expect(screen.getByText('Topic extraction')).toBeInTheDocument()
+    expect(screen.getByText('CSV uploads')).toBeInTheDocument()
+    expect(screen.getByText('Upgrade to Pro')).toBeInTheDocument()
+  })
+
+  it('displays data management options', () => {
+    render(<Settings />)
+    
+    expect(screen.getByText('Export Feedback')).toBeInTheDocument()
+    expect(screen.getByText('Download your feedback data as a CSV file.')).toBeInTheDocument()
+    expect(screen.getByText('Export CSV')).toBeInTheDocument()
+    
+    // Check for the Delete Account heading
+    expect(screen.getByRole('heading', { name: 'Delete Account', level: 3 })).toBeInTheDocument()
+    expect(screen.getByText('Permanently delete your account and all associated data. This action cannot be undone.')).toBeInTheDocument()
+    // Check for the Delete Account button
+    expect(screen.getByRole('button', { name: 'Delete Account' })).toBeInTheDocument()
+  })
+
+  it('handles missing user gracefully', () => {
+    // Set the mock user to null for this test
+    mockAuthStore.user = null
+    
+    render(<Settings />)
+    
+    // Should render without crashing
+    expect(screen.getByText('Settings')).toBeInTheDocument()
+    
+    // Email and business name inputs should have empty values
+    const emailInput = screen.getByLabelText('Email Address')
+    const businessNameInput = screen.getByLabelText('Business Name')
+    
+    expect(emailInput).toHaveValue('')
+    expect(businessNameInput).toHaveValue('')
+  })
+
+  it('handles user with missing business_name', () => {
+    // Set the mock user without business_name for this test
+    mockAuthStore.user = { id: 1, email: 'test@example.com' }
+    
+    render(<Settings />)
+    
+    const businessNameInput = screen.getByLabelText('Business Name')
+    expect(businessNameInput).toHaveValue('')
+  })
+
+  describe('Status Messages', () => {
+    it('displays success message when mutation succeeds', async () => {
+      // Mock the useMutation to capture the options and simulate success
+      let capturedOptions
+      mockUseMutation.mockImplementation((mutationFn, options) => {
+        capturedOptions = options
+        return {
+          mutate: (data) => {
+            // Simulate successful API call by calling onSuccess
+            capturedOptions.onSuccess()
+          },
+          isLoading: false
+        }
+      })
+      
+      render(<Settings />)
+      
+      // Trigger a successful update using act
+      act(() => {
+        fireEvent.click(screen.getByText('Save Changes'))
+      })
+      
+      // Wait for success message to appear
+      await waitFor(() => {
+        expect(screen.getByText('Business name updated successfully!')).toBeInTheDocument()
+      })
+      
+      // Check success styling - traverse up to find the status message container
+      const messageText = screen.getByText('Business name updated successfully!')
+      const statusContainer = messageText.closest('div').parentElement.parentElement
+      expect(statusContainer).toHaveClass('bg-green-50')
+    })
+
+    it('displays error message when mutation fails', async () => {
+      // Mock the useMutation to capture the options and simulate error
+      let capturedOptions
+      mockUseMutation.mockImplementation((mutationFn, options) => {
+        capturedOptions = options
+        return {
+          mutate: (data) => {
+            // Simulate API error by calling onError
+            capturedOptions.onError({
+              response: {
+                data: {
+                  detail: 'Business name already exists'
+                }
+              }
+            })
+          },
+          isLoading: false
+        }
+      })
+      
+      render(<Settings />)
+      
+      // Trigger a failed update using act
+      act(() => {
+        fireEvent.click(screen.getByText('Save Changes'))
+      })
+      
+      // Wait for error message to appear
+      await waitFor(() => {
+        expect(screen.getByText('Business name already exists')).toBeInTheDocument()
+      })
+      
+      // Check error styling - traverse up to find the status message container
+      const messageText = screen.getByText('Business name already exists')
+      const statusContainer = messageText.closest('div').parentElement.parentElement
+      expect(statusContainer).toHaveClass('bg-red-50')
+    })
+
+    it('displays generic error message when no detail provided', async () => {
+      // Mock the useMutation to capture the options and simulate generic error
+      let capturedOptions
+      mockUseMutation.mockImplementation((mutationFn, options) => {
+        capturedOptions = options
+        return {
+          mutate: (data) => {
+            // Simulate generic error by calling onError
+            capturedOptions.onError({
+              response: {
+                data: {}
+              }
+            })
+          },
+          isLoading: false
+        }
+      })
+      
+      render(<Settings />)
+      
+      // Trigger error using act
+      act(() => {
+        fireEvent.click(screen.getByText('Save Changes'))
+      })
+      
+      // Wait for error message to appear
+      await waitFor(() => {
+        expect(screen.getByText('Failed to update business name')).toBeInTheDocument()
+      })
+    })
+
+    it('allows dismissing status messages', async () => {
+      // Mock the useMutation to capture the options and simulate success
+      let capturedOptions
+      mockUseMutation.mockImplementation((mutationFn, options) => {
+        capturedOptions = options
+        return {
+          mutate: (data) => {
+            capturedOptions.onSuccess()
+          },
+          isLoading: false
+        }
+      })
+      
+      render(<Settings />)
+      
+      // Trigger success message using act
+      act(() => {
+        fireEvent.click(screen.getByText('Save Changes'))
+      })
+      
+      await waitFor(() => {
+        expect(screen.getByText('Business name updated successfully!')).toBeInTheDocument()
+      })
+      
+      // Dismiss the message using fireEvent wrapped in act
+      const dismissButton = screen.getByRole('button', { name: 'Dismiss' })
+      act(() => {
+        fireEvent.click(dismissButton)
+      })
+      
+      // Wait for the message to be removed
+      await waitFor(() => {
+        expect(screen.queryByText('Business name updated successfully!')).not.toBeInTheDocument()
+      })
+    })
+  })
+
+  describe('Form Interactions', () => {
+    it('has proper form accessibility', () => {
+      const { container } = render(<Settings />)
+      
+      // Check for proper labels
+      expect(screen.getByLabelText('Email Address')).toBeInTheDocument()
+      expect(screen.getByLabelText('Business Name')).toBeInTheDocument()
+      
+      // Check form element exists
+      const form = container.querySelector('form')
+      expect(form).toBeInTheDocument()
+      
+      // Verify the form has the submit button
+      expect(screen.getByRole('button', { name: 'Save Changes' })).toBeInTheDocument()
+    })
+
+    it('submits form when form submit event is triggered', async () => {
+      const { container } = render(<Settings />)
+      
+      const businessNameInput = screen.getByDisplayValue('Test Business')
+      const form = container.querySelector('form')
+      
+      // Change value using fireEvent wrapped in act
+      act(() => {
+        fireEvent.change(businessNameInput, {
+          target: { value: 'New Name' }
+        })
+      })
+      
+      // Submit form by triggering the submit event on the form element
+      act(() => {
+        fireEvent.submit(form)
+      })
+      
+      // Wait for the mutation to be called
+      await waitFor(() => {
+        expect(mockMutationReturn.mutate).toHaveBeenCalledWith('New Name')
+      })
+    })
+  })
+
+  describe('Button Interactions', () => {
+    it('renders all action buttons', () => {
+      render(<Settings />)
+      
+      expect(screen.getByRole('button', { name: 'Save Changes' })).toBeInTheDocument()
+      expect(screen.getByRole('button', { name: 'Export CSV' })).toBeInTheDocument()
+      expect(screen.getByRole('button', { name: 'Delete Account' })).toBeInTheDocument()
+      expect(screen.getByRole('button', { name: 'Upgrade to Pro' })).toBeInTheDocument()
+    })
+
+    it('applies correct styling to buttons', () => {
+      render(<Settings />)
+      
+      const saveButton = screen.getByText('Save Changes')
+      expect(saveButton).toHaveClass('bg-primary-600', 'hover:bg-primary-700')
+      
+      // Use getByRole to be more specific about which Delete Account element we want
+      const deleteButton = screen.getByRole('button', { name: 'Delete Account' })
+      expect(deleteButton).toHaveClass('text-red-700', 'border-red-300')
+      
+      const upgradeButton = screen.getByText('Upgrade to Pro')
+      expect(upgradeButton).toHaveClass('bg-primary-600', 'hover:bg-primary-700')
+    })
+  })
+})
-- 
2.39.5 (Apple Git-154)

